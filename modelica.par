%start stored_definition
%title "Modelica grammar"
%comment "Modelica grammar 3.7-dev for `parol`"
%line_comment "//"
%block_comment "/\*" "\*/"
%t_type crate::ir::ast::Token
%nt_type algorithm_section = crate::modelica_grammar::AlgorithmSection
%nt_type argument = crate::ir::ast::Expression
%nt_type argument_list = crate::modelica_grammar::ExpressionList
%nt_type arithmetic_expression = crate::ir::ast::Expression
%nt_type array_subscripts = crate::modelica_grammar::ArraySubscripts
%nt_type class_definition = crate::ir::ast::ClassDefinition
%nt_type component_list = crate::modelica_grammar::ComponentList
%nt_type component_reference = crate::ir::ast::ComponentReference
%nt_type component_ref_part = crate::ir::ast::ComponentRefPart
%nt_type composition = crate::modelica_grammar::Composition
%nt_type description_string = crate::modelica_grammar::TokenList
%nt_type element_list = crate::modelica_grammar::ElementList
%nt_type equation_block = crate::ir::ast::EquationBlock
%nt_type equation_section = crate::modelica_grammar::EquationSection
%nt_type expression = crate::ir::ast::Expression
%nt_type factor = crate::ir::ast::Expression
%nt_type function_call_args = crate::modelica_grammar::ExpressionList
%nt_type function_argument = crate::ir::ast::Expression
%nt_type function_arguments = crate::modelica_grammar::ExpressionList
%nt_type function_arguments_non_first = crate::modelica_grammar::ExpressionList
%nt_type ident = crate::ir::ast::Token
%nt_type logical_expression = crate::ir::ast::Expression
%nt_type logical_factor = crate::ir::ast::Expression
%nt_type logical_term = crate::ir::ast::Expression
%nt_type name = crate::ir::ast::Name
%nt_type output_expression_list = crate::modelica_grammar::ExpressionList
%nt_type primary = crate::ir::ast::Expression
%nt_type relation = crate::ir::ast::Expression
%nt_type simple_expression = crate::ir::ast::Expression
%nt_type some_equation = crate::ir::ast::Equation
%nt_type statement = crate::ir::ast::Statement
%nt_type statement_block = crate::ir::ast::StatementBlock
%nt_type stored_definition = crate::ir::ast::StoredDefinition
%nt_type string = crate::ir::ast::Token
%nt_type subscript = crate::ir::ast::Subscript
%nt_type term = crate::ir::ast::Expression
%nt_type unsigned_integer = crate::ir::ast::Token
%nt_type unsigned_real = crate::ir::ast::Token

%%

// ‚úÖ: Implemented,  üü•: Not-Implemented, üü®: Partial
//=============================================================================
// 2.3.3 Modelica Keywords
algorithm
    : 'algorithm'
    ;

and : 'and'
    ;

annotation
    : 'annotation'
    ;

block
    : 'block'
    ;

break
    : 'break'
    ;

class
    : 'class'
    ;

connect
    : 'connect'
    ;

connector
    : 'connector'
    ;

constant
    : 'constant'
    ;

constrainedby
    : 'constrainedby'
    ;

der : 'der'
    ;

discrete
    : 'discrete'
    ;

each: 'each'
    ;

else: 'else'
    ;

elseif
    : 'elseif'
    ;

elsewhen
    : 'elsewhen'
    ;

encapsulated
    : 'encapsulated'
    ;

end : 'end'
    ;

enumeration
    : 'enumeration'
    ;

equation
    : 'equation'
    ;

expandable
    : 'expandable'
    ;

extends
    : 'extends'
    ;

external
    : 'external'
    ;

false
    : 'false'
    ;

final
    : 'final'
    ;

flow: 'flow'
    ;

for : 'for'
    ;

function
    : 'function'
    ;

if  : 'if'
    ;

import
    : 'import'
    ;

impure
    : 'impure'
    ;

in  : 'in'
    ;

initial
    : 'initial'
    ;

inner
    : 'inner'
    ;

input
    : 'input'
    ;

loop: 'loop'
    ;

model
    : 'model'
    ;

not : 'not'
    ;

operator
    : 'operator'
    ;

or  : 'or'
    ;

outer
    : 'outer'
    ;

output
    : 'output'
    ;

package
    : 'package'
    ;

parameter
    : 'parameter'
    ;

partial
    : 'partial'
    ;

protected
    : 'protected'
    ;

public
    : 'public'
    ;

pure: 'pure'
    ;

record
    : 'record'
    ;

redeclare
    : 'redeclare'
    ;

replaceable
    : 'replaceable'
    ;

return
    : 'return'
    ;

stream
    : 'stream'
    ;

then: 'then'
    ;

true: 'true'
    ;

type: 'type'
    ;

when: 'when'
    ;

while
    : 'while'
    ;

within
    : 'within'
    ;

//=============================================================================
// A.1 Lexical conventions
// IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
ident
    : /[_a-zA-Z][_a-zA-Z0-9]*/@basic_ident
    | /\'[_a-zA-Z0-9!#\$%&\(\)\*\+,-\.\/:;<>=\?@\[\]\^\{\}\|~ \"]*\'/@q_ident
    ;

// üü® IDENT = NON-DIGIT { DIGIT | NON-DIGIT } | Q-IDENT
// üü® Q-IDENT = "'" { Q-CHAR | S-ESCAPE } "'"
// ‚úÖ NON-DIGIT = "_" | letters "a"..."z" | letters "A"..."Z"
// ‚úÖ DIGIT = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
// ‚úÖ Q-CHAR = NON-DIGIT | DIGIT | "!" | "#" | "$" | "%" | "&" | "(" | ")"
//    | "*" | "+" s| "," | "-" | "." | "/" | ":" | ";" | "<" | ">" | "="
//    | "?" | "@" | "[" | "]" | "^" | "{" | "}" | "|" | "~" | " " | """
// üü• S-ESCAPE = "\'" | "\"" | "\?" | "\\"
//    | "\a" | "\b" | "\f" | "\n" | "\r" | "\t" | "\v"
// üü® STRING = """ { S-CHAR | S-ESCAPE } """ ;
string
    : /"[' \w]*"/
    ;

// S-CHAR is any member of the Unicode character set
// (https://unicode.org; see section 13.4 for storing as UTF-8 on files)
// except double-quote ‚Äò‚Äù‚Äô, and backslash ‚Äò\‚Äô.
// UNSIGNED-INTEGER = DIGIT { DIGIT }
unsigned_integer
    : /[0-9]+/
    ;

// UNSIGNED-REAL =
//    UNSIGNED-INTEGER  "." [ UNSIGNED-INTEGER ]
//    | UNSIGNED_INTEGER [ "." [ UNSIGNED_INTEGER ] ]
//      ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER
//    | "."  UNSIGNED-INTEGER [ ( "e" | "E" ) [ "+" | "-" ] UNSIGNED-INTEGER ]
unsigned_real
    : /[0-9]+\.[0-9]+/@decimal
    | /[0-9]+\.([0-9]+)?([eE][+-]?[0-9]+)?/@scientific
    | /\.[0-9]+([eE][+-]?[0-9]+)?/@scientific2
    ;

//=============================================================================
// A.2.1 Stored Definition ‚Äì Within
//‚úÖ stored-definition :
//‚úÖ    [ within [ name ] ";" ]
//‚úÖ    { [ final ] class-definition ";" }
stored_definition
    : [ within^ [ name ] ';'^ ] { [ final ] class_definition ';'^ }
    ;

//=============================================================================
// A.2.2 Class Definition
//‚úÖ class-definition :
//‚úÖ    [ encapsulated ] class-prefixes class-specifier
class_definition
    : [ encapsulated ] class_prefixes class_specifier
    ;

//‚úÖ class-prefixes :
//‚úÖ    [ partial ]
//‚úÖ    ( class
//‚úÖ      | model
//‚úÖ      | [ operator ] record
//‚úÖ      | block
//‚úÖ      | [ expandable ] connector
//‚úÖ      | type
//‚úÖ      | package
//‚úÖ      | [ pure | impure ] [ operator ] function
//‚úÖ      | operator
//‚úÖ    )
class_type
    : class
    | model
    | [ operator ] record
    | block
    | [ expandable ] connector
    | type
    | package
    | [ pure | impure ] [ operator ] function
    | operator
    ;

class_prefixes
    : [ partial ] class_type
    ;

//‚úÖ class-specifier :
//‚úÖ    long-class-specifier
//‚úÖ    | short-class-specifier
//‚úÖ    | der-class-specifier
class_specifier
    : long_class_specifier
    | short_class_specifier
    | der_class_specifier
    ;

//‚úÖ long-class-specifier :
//‚úÖ    IDENT description-string composition end IDENT
//‚úÖ    | extends IDENT [ class-modification ] description-string composition end IDENT
long_class_specifier
    : standard_class_specifier
    | extends_class_specifier
    ;

standard_class_specifier
    : ident@name description_string composition end^ ident
    ;

extends_class_specifier
    : extends^ ident [ class_modification ] description_string composition end^ ident
    ;

//‚úÖ short-class-specifier :
//‚úÖ    IDENT "=" base-prefix type-specifier [ array-subscripts ]
//‚úÖ    [ class-modification ] description
//‚úÖ    | IDENT "=" enumeration "(" ( [ enum-list ] | ":" ) ")" description
short_class_specifier
    : type_class_specifier
    | enum_class_specifier
    ;

type_class_specifier
    : ident '='^ base_prefix type_specifier [ array_subscripts ] [ class_modification ] description
    ;

enum_class_specifier
    : ident '='^ enumeration '('^ ( [ enum_list ] | ':'^ ) ')'^ description
    ;

//‚úÖ der-class-specifier :
//‚úÖ    IDENT "=" der "(" type-specifier "," IDENT { "," IDENT } ")" description
der_class_specifier
    : ident '='^ der '('^ type_specifier ','^ ident { ','^ ident } ')'^ description
    ;

//‚úÖ base-prefix :
//‚úÖ    [ input | output ]
base_prefix
    : [ input | output ]
    ;

//‚úÖ enum-list :
//‚úÖ    enumeration-literal { "," enumeration-literal }
enum_list
    : enumeration_literal { ','^ enumeration_literal }
    ;

//‚úÖ enumeration-literal :
//‚úÖ    IDENT description
enumeration_literal
    : ident description
    ;

//‚úÖ composition :
//‚úÖ    element-list
//‚úÖ    { public element-list
//‚úÖ      | protected element-list
//‚úÖ      | equation-section
//‚úÖ      | algorithm-section
//‚úÖ    }
//‚úÖ    [ external [ language-specification ]
//‚úÖ      [ external-function-call ] [ annotation-clause ] ";"
//‚úÖ    ]
//‚úÖ    [ annotation-clause ";" ]
composition
    : element_list
      { public element_list | protected element_list | equation_section | algorithm_section }
      [ external^ [ language_specification ] [ external_function_call ] [ annotation_clause ] ';'^ ]
      [ annotation_clause ';'^ ]
    ;

//‚úÖ language-specification :
//‚úÖ    STRING
language_specification
    : string
    ;

//‚úÖ external-function-call :
//‚úÖ    [ component-reference "=" ]
//‚úÖ    IDENT "(" [ expression-list ] ")"
external_function_call
    : [ component_reference '='^ ] ident '('^ [ expression_list ] ')'^
    ;

//‚úÖ element-list :
//‚úÖ    { element ";" }
element_list
    : { element ';'^ }
    ;

//‚úÖ element :
//‚úÖ    import-clause
//‚úÖ    | extends-clause
//‚úÖ    | [ redeclare ]
//‚úÖ      [ final ]
//‚úÖ      [ inner ] [ outer ]
//‚úÖ      ( class-definition
//‚úÖ        | component-clause
//‚úÖ        | replaceable ( class-definition | component-clause )
//‚úÖ          [ constraining-clause description ]
//‚úÖ      )
element
    : import_clause
    | extends_clause
    | element_definition
    | element_replaceable_definition
    ;

element_definition
    : [ redeclare ] [ final ] [ inner ] [ outer ] ( class_definition | component_clause )
    ;

element_replaceable_definition
    : replaceable ( class_definition | component_clause ) [ constraining_clause description ]
    ;

//‚úÖ import-clause :
//‚úÖ    import
//‚úÖ    ( IDENT "=" name
//‚úÖ      | name [ ".*" | "." ( "*" | "{" import-list "}" ) ]
//‚úÖ    )
//‚úÖ    description
import_clause
    : import^ ( renaming_import | import_statement ) description
    ;

renaming_import
    : ident '='^ name
    ;

import_statement
    : name [ '.*' | '.' ( '*' | '{' import_list '}' ) ]
    ;

//‚úÖ import-list :
//‚úÖ    IDENT { "," IDENT }
import_list
    : ident { ','^ ident }
    ;

//=============================================================================
// A.2.3 Extends
//‚úÖ extends-clause :
//‚úÖ    extends type-specifier [ class-or-inheritance-modification ] [ annotation-clause ]
extends_clause
    : extends^ type_specifier [ class_or_inheritance_modification ] [ annotation_clause ]
    ;

//‚úÖ constraining-clause :
//‚úÖ    constrainedby type-specifier [ class-modification ]
constraining_clause
    : constrainedby^ type_specifier [ class_modification ]
    ;

//‚úÖ class-or-inheritance-modification :
//‚úÖ    "(" [ argument-or-inheritance-modification-list ] ")"
class_or_inheritance_modification
    : '('^ [ argument_or_inheritance_modification_list ] ')'^
    ;

//‚úÖ argument-or-inheritance-modification-list :
//‚úÖ     ( argument | inheritance-modification ) { "," ( argument | inheritance-modification ) }
argument_or_inheritance_modification_list
    : ( argument | inheritance_modification ) { ','^ ( argument | inheritance_modification ) }
    ;

//‚úÖ inheritance-modification :
//‚úÖ     break ( connect-equation | IDENT )
inheritance_modification
    : break^ ( connect_equation | ident )
    ;

//-----------------------------------------------------------------------------
// A.2.4 Component Clause
//‚úÖ component-clause :
//‚úÖ    type-prefix type-specifier [ array-subscripts ] component-list
component_clause
    : type_prefix type_specifier [ array_subscripts ] component_list
    ;

//‚úÖ type-prefix :
//‚úÖ    [ flow | stream ]
//‚úÖ    [ discrete | parameter | constant ]
//‚úÖ    [ input | output ]
type_prefix
    : [ flow | stream ] [ discrete | parameter | constant ] [ input | output ]
    ;

//‚úÖ component-list :
//‚úÖ    component-declaration { "," component-declaration }
component_list
    : component_declaration { ','^ component_declaration }
    ;

//‚úÖ component-declaration :
//‚úÖ    declaration [ condition-attribute ] description
component_declaration
    : declaration [ condition_attribute ] description
    ;

//‚úÖ condition-attribute :
//‚úÖ    if expression
condition_attribute
    : if^ expression
    ;

//‚úÖ declaration :
//‚úÖ    IDENT [ array-subscripts ] [ modification ]
declaration
    : ident [ array_subscripts ] [ modification ]
    ;

//=============================================================================
// A.2.5 Modification
//‚úÖ modification :
//‚úÖ    class-modification [ "=" modification-expression ]
//‚úÖ    | "=" modification-expression
modification
    : class_modification [ '='^ modification_expression ]
    | '='^ modification_expression
    ;

//‚úÖ modification-expression :
//‚úÖ    expression
//‚úÖ    | break
modification_expression
    : expression
    | break
    ;

//‚úÖ class-modification :
//‚úÖ    "(" [ argument-list ] ")"
class_modification
    : '('^ [ argument_list ] ')'^
    ;

//‚úÖ argument-list :
//‚úÖ    argument { "," argument }
argument_list
    : argument { ','^ argument }
    ;

//‚úÖ argument :
//‚úÖ    element-modification-or-replaceable
//‚úÖ    | element-redeclaration
argument
    : element_modification_or_replaceable
    | element_redeclaration
    ;

//‚úÖ element-modification-or-replaceable :
//‚úÖ    [ each ] [ final ] ( element-modification | element-replaceable )
element_modification_or_replaceable
    : [ each ] [ final ] ( element_modification | element_replaceable )
    ;

//‚úÖ element-modification :
//‚úÖ    name [ modification ] description-string
element_modification
    : name [ modification ] description_string
    ;

//‚úÖ element-redeclaration :
//‚úÖ    redeclare [ each ] [ final ]
//‚úÖ    ( short-class-definition | component-clause1 | element-replaceable )
element_redeclaration
    : redeclare [ each ] [ final ]
      ( short_class_definition | component_clause1 | element_replaceable )
    ;

//‚úÖ element-replaceable :
//‚úÖ    replaceable ( short-class-definition | component-clause1 )
//‚úÖ    [ constraining-clause ]
element_replaceable
    : replaceable ( short_class_definition | component_clause1 ) [ constraining_clause ]
    ;

//‚úÖ component-clause1 :
//‚úÖ    type-prefix type-specifier component-declaration1
component_clause1
    : type_prefix type_specifier component_declaration1
    ;

//‚úÖ component-declaration1 :
//‚úÖ    declaration description
component_declaration1
    : declaration description
    ;

//‚úÖ short-class-definition :
//‚úÖ    class-prefixes short-class-specifier
short_class_definition
    : class_prefixes short_class_specifier
    ;

//=============================================================================
// A.2.6 Equations
//‚úÖ equation-section :
//‚úÖ    [ initial ] equation { some-equation ";" }
equation_section
    : [ initial^ ] equation^ { some_equation ';'^ }
    ;

//‚úÖ algorithm-section :
//‚úÖ    [ initial ] algorithm { statement ";" }
algorithm_section
    : [ initial^ ] algorithm^ { statement ';'^ }
    ;

//‚úÖ some-equation :
//‚úÖ    ( simple-expression "=" expression
//‚úÖ      | if-equation
//‚úÖ      | for-equation
//‚úÖ      | connect-equation
//‚úÖ      | when-equation
//üü•      | component-reference function-call-args
//‚úÖ    )
//‚úÖ    description
some_equation_option
    : simple_equation
    | if_equation
    | for_equation
    | connect_equation
    | when_equation
    ;

// This also handles componet-reference function-call-args
// this is necessary otherwise, look-ahead is very large
// if rhs is not present, only a function call is allowed,
// this is checked in the parser, if rhs is present, then
// it is a standrd simple_equation
simple_equation
    : simple_expression [ '='^ expression ]
    ;

some_equation
    : some_equation_option description
    ;

//‚úÖ statement :
//‚úÖ    ( component-reference ( ":=" expression | function-call-args )
//‚úÖ      | "(" output-expression-list ")" ":=" component-reference function-call-args
//‚úÖ      | break
//‚úÖ      | return
//‚úÖ      | if-statement
//‚úÖ      | for-statement
//‚úÖ      | while-statement
//‚úÖ      | when-statement
//‚úÖ    )
//‚úÖ    description
statement_option
    : component_statement
    | function_call_output_statement
    | break
    | return
    | if_statement
    | for_statement
    | while_statement
    | when_statement
    ;

component_statement
    : component_reference ( ':='^ expression | function_call_args )
    ;

function_call_output_statement
    : '('^ output_expression_list ')'^ ':='^ component_reference function_call_args
    ;

statement
    : statement_option description
    ;

//‚úÖ if-equation :
//‚úÖ    if expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    { elseif expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    }
//‚úÖ    [ else
//‚úÖ      { some-equation ";" }
//‚úÖ    ]
//‚úÖ    end if
equation_block
    : expression then^ { some_equation ';'^ }
    ;

if_equation
    : if^ equation_block@if { elseif^ equation_block@elseif } [ else^ { some_equation ';'^ } ] end^
      if^
    ;

//‚úÖ if-statement :
//‚úÖ    if expression then
//‚úÖ      { statement ";" }
//‚úÖ    { elseif expression then
//‚úÖ      { statement ";" }
//‚úÖ    }
//‚úÖ    [ else
//‚úÖ      { statement ";" }
//‚úÖ    ]
//‚úÖ    end if
statement_block
    : expression then^ { statement ';'^ }
    ;

if_statement
    : if^ statement_block@if { elseif^ statement_block@elseif } [ else^ { statement@else ';'^ } ]
      end^ if^
    ;

//‚úÖ for-equation :
//‚úÖ    for for-indices loop
//‚úÖ      { some-equation ";" }
//‚úÖ    end for
for_equation
    : for^ for_indices loop^ { some_equation ';'^ } end^ for^
    ;

//‚úÖ for-statement :
//‚úÖ    for for-indices loop
//‚úÖ      { statement ";" }
//‚úÖ    end for
for_statement
    : for^ for_indices loop^ { statement ';'^ } end^ for^
    ;

//‚úÖ for-indices :
//‚úÖ    for-index { "," for-index }
for_indices
    : for_index { ','^ for_index }
    ;

//‚úÖ for-index :
//‚úÖ    IDENT [ in expression ]
for_index
    : ident [ in^ expression ]
    ;

//‚úÖ while-statement :
//‚úÖ    while expression loop
//‚úÖ      { statement ";" }
//‚úÖ    end while
while_statement
    : while^ expression loop^ { statement ';'^ } end^ while^
    ;

//‚úÖ when-equation :
//‚úÖ    when expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    { elsewhen expression then
//‚úÖ      { some-equation ";" }
//‚úÖ    }
//‚úÖ    end when
when_equation
    : when^ equation_block@when { elsewhen^ equation_block@elsewhen } end^ when^
    ;

//‚úÖ when-statement :
//‚úÖ    when expression then
//‚úÖ      { statement ";" }
//‚úÖ    { elsewhen expression then
//‚úÖ      { statement ";" }
//‚úÖ    }
//‚úÖ    end when
when_statement
    : when^ statement_block@when { elsewhen^ statement_block@elsewhen } end^ when^
    ;

//‚úÖ connect-equation :
//‚úÖ    connect "(" component-reference "," component-reference ")"
connect_equation
    : connect^ '('^ component_reference ','^ component_reference ')'^
    ;

//=============================================================================
// A.2.7 Expressions
//‚úÖ expression :
//‚úÖ    simple-expression
//‚úÖ    | if expression then expression
//‚úÖ      { elseif expression then expression }
//‚úÖ      else expression
expression
    : simple_expression
    | if_expression
    ;

if_expression
    : if^ expression then^ expression { elseif^ expression then^ expression } else^ expression
    ;

//‚úÖ simple-expression :
//‚úÖ    logical-expression [ ":" logical-expression [ ":" logical-expression ] ]
simple_expression
    : logical_expression [ ':'^ logical_expression [ ':'^ logical_expression ] ]
    ;

//‚úÖ logical-expression :
//‚úÖ    logical-term { or logical-term }
logical_expression
    : logical_term { or^ logical_term }
    ;

//‚úÖ logical-term :
//‚úÖ    logical-factor { and logical-factor }
logical_term
    : logical_factor { and^ logical_factor }
    ;

//‚úÖ logical-factor :
//‚úÖ    [ not ] relation
logical_factor
    : [ not ] relation
    ;

//‚úÖ relation :
//‚úÖ    arithmetic-expression [ relational-operator arithmetic-expression ]
relation
    : arithmetic_expression [ relational_operator arithmetic_expression ]
    ;

//‚úÖ relational-operator :
//‚úÖ    "<" | "<=" | ">" | ">=" | "==" | "<>"
relational_operator
    : '<'
    | '<='
    | '>'
    | '>='
    | '=='
    | '<>'
    ;

//‚úÖ arithmetic-expression :
//‚úÖ    [ add-operator ] term { add-operator term }
arithmetic_expression
    : [ add_operator ] term { add_operator term }
    ;

//‚úÖ add-operator :
//‚úÖ    "+" | "-" | ".+" | ".-"
add_operator
    : '+'
    | '-'
    | '.+'
    | '.-'
    ;

//‚úÖ term :
//‚úÖ    factor { mul-operator factor }
term: factor { mul_operator factor }
    ;

//‚úÖ mul-operator :
//‚úÖ    "*" | "/" | ".*" | "./"
mul_operator
    : '*'
    | '/'
    | '.*'
    | './'
    ;

//‚úÖ factor :
//‚úÖ    primary [ ( "^" | ".^" ) primary ]
factor
    : primary { ( '^' | '.^' ) primary }
    ;

//‚úÖ primary :
//‚úÖ    UNSIGNED-NUMBER
//‚úÖ    | STRING
//‚úÖ    | false
//‚úÖ    | true
//‚úÖ    | ( component-reference | der | initial | pure ) function-call-args
//‚úÖ    | component-reference
//‚úÖ    | "(" output-expression-list ")" [ ( array-subscripts | "." IDENT ) ]
//‚úÖ    | "[" expression-list { ";" expression-list } "]"
//‚úÖ    | "{" array-arguments "}"
//‚úÖ    | end
primary
    : unsigned_number
    | string
    | false
    | true
    | global_function_call
    | component_primary
    | output_primary
    | range_primary
    | array_primary
    | end
    ;

component_primary
    : component_reference [ function_call_args ]
    ;

output_primary
    : '('^ output_expression_list ')'^ [ ( array_subscripts | '.'^ ident ) ]
    ;

range_primary
    : '['^ expression_list { ';'^ expression_list } ']'^
    ;

array_primary
    : '{'^ array_arguments '}'^
    ;

global_function_call
    : ( der | initial | pure ) function_call_args
    ;

//‚úÖ UNSIGNED-NUMBER :
//‚úÖ    UNSIGNED-INTEGER | UNSIGNED-REAL
unsigned_number
    : unsigned_integer
    | unsigned_real
    ;

//‚úÖ type-specifier :
//‚úÖ    ["."] name
type_specifier
    : [ '.'^ ] name
    ;

//‚úÖ name :
//‚úÖ    IDENT { "." IDENT }
name: ident { '.'^ ident }
    ;

//‚úÖ component-reference :
//‚úÖ    [ "." ] IDENT [ array-subscripts ] { "." IDENT [ array-subscripts ] }
component_reference
    : [ '.'^ ] ident [ array_subscripts ] { component_ref_part }
    ;

component_ref_part
    : '.'^ ident [ array_subscripts ]
    ;

//‚úÖ function-call-args :
//‚úÖ    "(" [ function-arguments ] ")"
function_call_args
    : '('^ [ function_arguments ] ')'^
    ;

//‚úÖ function-arguments :
//‚úÖ    expression [ "," function-arguments-non-first | for for-indices ]
//‚úÖ    | function-partial-application [ "," function-arguments-non-first ]
//‚úÖ    | named-arguments
function_arguments
    : expression [ ','^ function_arguments_non_first | for for_indices ]
    | function_partial_application [ ','^ function_arguments_non_first ]
    | named_arguments
    ;

//‚úÖ function-arguments-non-first :
//‚úÖ    function-argument [ "," function-arguments-non-first ]
//‚úÖ    | named-arguments
function_arguments_non_first
    : function_argument [ ','^ function_arguments_non_first ]
    | named_arguments
    ;

//‚úÖ array-arguments :
//‚úÖ    expression [ "," array-arguments-non-first | for for-indices ]
array_arguments
    : expression [ ','^ array_arguments_non_first | for for_indices ]
    ;

//‚úÖ array-arguments-non-first :
//‚úÖ    expression [ "," array-arguments-non-first ]
array_arguments_non_first
    : expression [ ','^ array_arguments_non_first ]
    ;

//‚úÖ named-arguments: named-argument [ "," named-arguments ]
named_arguments
    : named_argument [ ','^ named_arguments ]
    ;

//‚úÖ named-argument: IDENT "=" function-argument
named_argument
    : ident '='^ function_argument
    ;

//‚úÖ function-argument :
//‚úÖ    function-partial-application | expression
function_argument
    : function_partial_application
    | expression
    ;

//‚úÖ function-partial-application :
//‚úÖ    function type-specifier "(" [ named-arguments ] ")"
function_partial_application
    : function type_specifier '('^ [ named_arguments ] ')'^
    ;

//‚úÖ output-expression-list :
//‚úÖ    [ expression ] { "," [ expression ] }
output_expression_list
    : [ expression ] { ','^ [ expression ] }
    ;

//‚úÖ expression-list :
//‚úÖ    expression { "," expression }
expression_list
    : expression { ','^ expression }
    ;

//‚úÖ array-subscripts :
//‚úÖ    "[" subscript { "," subscript } "]"
array_subscripts
    : '['^ subscript { ','^ subscript } ']'^
    ;

//‚úÖ subscript :
//‚úÖ    ":" | expression
subscript
    : ':'
    | expression
    ;

//‚úÖ description :
//‚úÖ    description-string [ annotation-clause ]
description
    : description_string [ annotation_clause ]
    ;

//‚úÖ description-string :
//‚úÖ    [ STRING { "+" STRING } ]
description_string
    : [ string { '+'^ string } ]
    ;

//‚úÖ annotation-clause :
//‚úÖ    annotation class-modification
annotation_clause
    : annotation class_modification
    ;
